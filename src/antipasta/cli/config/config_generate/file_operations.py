"""File operations for configuration generation."""

from pathlib import Path
import sys
from typing import Any

import click
from pydantic import ValidationError
import yaml

from antipasta.core.config import AntipastaConfig


def _dump_scalar(value: Any) -> str:
    """Serialize a scalar to YAML without trailing newline."""
    dumped = yaml.safe_dump(
        value,
        allow_unicode=False,
        default_flow_style=False,
        sort_keys=False,
        explicit_end=False,
    ).strip()
    return dumped.splitlines()[0] if dumped else ""


def save_config(config: AntipastaConfig, output: Path) -> None:
    """Save configuration to file with helpful comments."""
    # Convert to dict for customization
    data = config.model_dump(exclude_none=True, mode="json")

    # Create YAML content with comments
    yaml_lines = []
    yaml_lines.append("# antipasta configuration file")  # noqa: FURB113
    yaml_lines.append("# Generated by: antipasta config generate")
    yaml_lines.append("")
    yaml_lines.append("# Default thresholds for all languages")
    yaml_lines.append("defaults:")

    defaults = data.get("defaults", {})
    cyclo_max = defaults.get("max_cyclomatic_complexity", 10)
    cog_max = defaults.get("max_cognitive_complexity", 15)
    maint_min = defaults.get("min_maintainability_index", 50)
    yaml_lines.append(
        f"  max_cyclomatic_complexity: {_dump_scalar(cyclo_max)}"
    )  # noqa: FURB113
    yaml_lines.append(f"  max_cognitive_complexity: {_dump_scalar(cog_max)}")
    yaml_lines.append(f"  min_maintainability_index: {_dump_scalar(maint_min)}")
    yaml_lines.append("  # Halstead metrics (advanced)")
    halstead_volume = _dump_scalar(defaults.get("max_halstead_volume", 1000))
    halstead_difficulty = _dump_scalar(defaults.get("max_halstead_difficulty", 10))
    halstead_effort = _dump_scalar(defaults.get("max_halstead_effort", 10000))
    yaml_lines.append(f"  max_halstead_volume: {halstead_volume}")
    yaml_lines.append(f"  max_halstead_difficulty: {halstead_difficulty}")
    yaml_lines.append(f"  max_halstead_effort: {halstead_effort}")

    yaml_lines.append("")
    yaml_lines.append("# Language-specific configurations")
    languages = data.get("languages") or []
    if languages:
        yaml_lines.append("languages:")
        for lang in languages:
            name = _dump_scalar(lang.get("name", ""))
            yaml_lines.append(f"  - name: {name}")

            extensions = lang.get("extensions") or []
            if extensions:
                yaml_lines.append("    extensions:")
                for ext in extensions:
                    yaml_lines.append(f"      - {_dump_scalar(ext)}")

            metrics = lang.get("metrics") or []
            if metrics:
                yaml_lines.append("    metrics:")
                for index, metric in enumerate(metrics):
                    metric_type = _dump_scalar(metric.get("type"))
                    threshold = _dump_scalar(metric.get("threshold"))
                    comparison = _dump_scalar(metric.get("comparison"))
                    yaml_lines.append(f"      - type: {metric_type}")  # noqa: FURB113
                    yaml_lines.append(f"        threshold: {threshold}")
                    yaml_lines.append(f"        comparison: {comparison}")
                    if index < len(metrics) - 1:
                        yaml_lines.append("")
            else:
                yaml_lines.append("    metrics: []")
    else:
        yaml_lines.append("languages: []")

    yaml_lines.append("")  # noqa: FURB113
    yaml_lines.append("# Files and patterns to ignore during analysis")
    patterns = data.get("ignore_patterns", [])
    if patterns:
        yaml_lines.append("ignore_patterns:")
        for pattern in patterns:
            yaml_lines.append(f"  - {_dump_scalar(pattern)}")
    else:
        yaml_lines.append("ignore_patterns: []")

    yaml_lines.append("")  # noqa: FURB113
    yaml_lines.append("# Whether to use .gitignore file for excluding files")
    yaml_lines.append(f"use_gitignore: {_dump_scalar(data.get('use_gitignore', True))}")

    # Write file
    try:
        output_path = Path(output)
        parent_dir = output_path.parent
        if parent_dir and not parent_dir.exists():
            try:
                parent_dir.mkdir(parents=True, exist_ok=True)
            except OSError as exc:
                raise PermissionError("Permission denied") from exc
        output_path.write_text("\n".join(yaml_lines) + "\n")

        click.echo(f"✅ Configuration saved to {output}")
        click.echo(f"\nRun 'antipasta config validate {output}' to verify.")
        click.echo("Run 'antipasta metrics' to start analyzing your code!")

    except Exception as e:
        click.echo(f"❌ Error saving configuration: {e}", err=True)
        sys.exit(1)


def confirm_file_overwrite(output: Path) -> bool:
    """Confirm file overwrite if file exists.

    Args:
        output: Output file path.

    Returns:
        True if should proceed, False otherwise.
    """
    click.echo(f"\nConfiguration will be saved to: {output}")

    if output.exists() and not click.confirm("File already exists. Overwrite?", default=False):
        click.echo("Aborted.")
        return False

    return True


def create_validated_config(config_dict: dict[str, Any]) -> AntipastaConfig:
    """Create and validate configuration object.

    Args:
        config_dict: Configuration dictionary.

    Returns:
        Validated AntipastaConfig object.

    Raises:
        SystemExit: If validation fails.
    """
    try:
        return AntipastaConfig(**config_dict)
    except ValidationError as e:
        handle_validation_error(e)
        sys.exit(1)
    except Exception as e:
        click.echo(f"\n❌ Unexpected error creating configuration: {e}", err=True)
        sys.exit(1)


def handle_validation_error(error: ValidationError) -> None:
    """Handle and display validation errors.

    Args:
        error: ValidationError from Pydantic.
    """
    click.echo("\n❌ Configuration validation failed:", err=True)
    for err in error.errors():
        loc = " -> ".join(str(x) for x in err["loc"])
        click.echo(f"  - {loc}: {err['msg']}", err=True)
    click.echo("\nPlease run the command again with valid values.", err=True)
